# 初步认识冒泡排序法
## 原理
比较相邻的元素。如果第一个比第二个大，就交换他们两个。

对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。

针对所有的元素重复以上的步骤，除了最后一个。

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
## 理解
冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。
## 代码示例
```c
//冒泡排序法
#include<stdio.h>
void mppx(int a[], int n){
	int i, j, t;
	for(i = 0; i < n; i++){//外循环进行n-1次 
		for(j = 0; j < n - 1 - i; j++){//内循环进行n减去外循环的次数 
			if(a[j] > a[j+1]){//前者大于后者就交换位置
				t = a[j];
				a[j] = a[j+1];
				a[j+1] = t;
			} 
		}
	}
}

int main()
{
	int a[10] = {5, 3, 2, 6, 8, 1, 4, 7, 9, 0};
	mppx(a, 10);
	for(int i = 0; i < 10; i++){
		printf("%d ", a[i]);
	}
	return 0;
}
```
## 测试结果
测试软件为Dev C++
![冒泡排序法示例](https://github.com/xycg529/Summer/blob/master/3.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%B8%8E%E6%8E%92%E5%BA%8F/pictures/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%E7%A4%BA%E4%BE%8B.PNG)
