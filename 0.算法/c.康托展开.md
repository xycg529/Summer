# 康托展开
## 算法的定义
    运用公式确定某一排列在所有排列中的字典序。举例而言，对于 1 ~ 4 的一个全排列 [1, 2, 3, 4] 和 [4, 3, 2, 1]，我们知道，从字典序而言，前者是该全排列集的第一个，后者是该集的最后一个。
    那么，所谓康托展开，即给定一个n位数的全排列，我们可以根据康托展开公式确定其应当是字典序中的第“几”个全排列。
    给定一个全排列，计算其字典序。我们举例[2, 3, 4, 1]来说明康托展开的运作步骤：令所求字典序为rank = 0。
    1.第一位是2，那么以 1 打头的所有全排列一定排在这个全排列之前，那么以 1 打头的全排列有 (3!) = 6种，rank = rank + 1x3! = 6
    2.第二位是3，那么以 1 与 2 作为第二位的所有全排列一定在这个圈排列之前。不过我们已经让 2 打头了，因此不需要再考虑 2 占第二位的情况，只需要计算 1 占第二位的情况。rank = rank + 1x2! = 8
    3.第三位是4，同时，我们计算以 1 占第三位的所有情况。rank = rank + 1x1! = 9
    4.最后一位，是不需要判定的，因为前n - 1位给定后，第n位自定。当然，为了也适应前面推导，可以记rank = rank + 0x0! = 9
    由是，排在 [2, 3, 4, 1] 之前的全排列共有 9 个，那么 [2, 3, 4, 1] 应当是第 10 个全排列。
## 代码实现
```c
//康托展开函数 
// BY WTU 计科11902 xycg529
int fact(int n)//定义阶乘函数 
{
	int i, sum = 1;
	for(i = 1; i <= n; i++){
		sum = sum*i;
	}
	return sum;
}
int cantor(int a[], int n)//定义康托展开函数
{
	int i, j, cnt = 0,  rank = 0;//cnt是数组每一位前面比它大的数的个数，rank+1是所求序数
	for(i = 1; i < n; i++){
		for(j = i + 1; j < n; j++){//每出现一个在当前位之前且比当前位数字大的数计数器+1
			if(a[i] > [j]){
				cnt++;
			}
		}
		rank += cnt * fact(n-i);
	}
	return rank+1;
}
```
